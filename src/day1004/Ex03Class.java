package day1004;
// 클래스와 객체
// 2세대 언어 절차 지향적 언어에서는
// 우리가 기능(메소드)만 재사용 가능하다라고 생각을 했다.
// 하지만 일종의 데이터타입인 구조체라는 개념도 새로 나오게 되고
// 그 구조체도 재사용하게 되면서 사람들이 관점이 더 발전하여
// 구조체와 메소드 모두다 재사용을 할 수 있는 방법을 찾기 시작하였다.
// 이렇게 진행이 되면서, 사람들이 구조체와 해당 구조체의 변수들이 가지고 있는 기능을
// 하나로 묶어서 취급하게 되는데
// 바로 그것이 클래스가 된다.

// 즉 클래스는 구조체 + 메소드 가 된다라는 것인데,
// 우리가 전에 만들었던 day1004.Ex02GradeBook01 을 보게 되면
// 전역상수+전역변수+메소드 가 모두 들어가 있게 된다.
// 하지만, 진정한 객체 지향 프로그래밍을 위해서는
// 우리가 해당 클래스의 변수를 만들어서 사용을 해야 한다!

// 객체 지향 프로그래밍은 프로그램을 더 작은 프로그램들의 집합으로 보게 되는데
// 우리가 지금까지 만들었던 클래스들은 하나하나가 별도의 프로그램이 되고
// 지금부터 만들 클래스들을 커다란 프로그램이 그 클래스들의 변수를 사용하는게
// 최종적인 객체지향프로그래밍의 형태를 가지게 되는 것이다.

// 객체(object)
// 객체란 무엇인가?
// 객체는 클래스 변수 를 객체라고 부른다.
// 즉 객체 지향 프로그래밍에서는 데이터를 저장할 공간과 해당 클래스 변수들이 공통적으로 실행시킬 메소드를
// 하나의 클래스로 묶고 그리고 커다란 프로그램이 해당 클래스 변수를 만들어서 사용을 하는 것이 목표가 된다.

// static 키워드
// static 키워드는 해당 메소드 혹은 변수/상수를 객체 없이 직접 사용을 할수 있게 만들어주는 키워드이다.
// 하지만, 객체 지향 프로그래밍에서는 클래스 변수, 즉 객체를 사용하여 데이터를 저장/호출 하거나
// 메소드를 사용하는 것이 원칙이다.
// 즉, 우리가 이제는 static 키워드의 사용을 점점 줄여나가다 궁극적으로는
// main 메소드 외에는 static 키워드를 사용하지 않게 되는 것이 목표가 된다!

// 클래스의 기본 구조
// 클래스는 필드와 메소드로 이루어져 있다.
// 필드:
// 해당 클래스 객체가 어떤 데이터를 저장할 수 있는지 선언한 부분.
// 즉 구조체와 형태가 같다.

// 메소드:
// 해당 클래스 객체가 실행시킬 기능.
// 단, 특정 객체 하나만 실행시키는 형태가 아니라 그 클래스의 객체이면 무조건 다 실행시킬 수 있는 형태로
// 만들게 된다.

// 생성자(Constructor)
// 생성자란, 해당 클래스 객체가 초기화 될때
// 어떠한 작업을 해야할 경우, 생성자를 통해서 해당 작업들이 실행되게 된다.
// 생성자는 기본적으로 해당 클래스 이름을 그대로 메소드 이름으로 가지게 된다.
// 만약 우리가 따로 생성자를 만들어주지 않을 경우에는
// 자바가 기본적으로 생성자를 제공해주는데
// 이 기본 생성자는 해당 객체의 필드만
// 기본형 데이터타입이면 0으로, 참조형 데이터타입이면 null로 초기화해준다.
// 우리가 직접 생성자를 만들 경우에는
// 다음과 같은 양식으로 만들어준다.
// public 클래스이름(파라미터) {
//     객체가 초기화 될때 실행할 코드
// }
// 만약 우리가 직접 생성자를 만들어줄 경우에는 한가지 주의할 사항이 있는데
// 파라미터가 있는 생성자만 만들 경우, 더이상 기본 생성자, 즉 파라미터 없는 생성자는
// 우리가 호출할 수 없게 된다!
// 따라서, 파라미터 있는 생성자와 파라미터가 없는 생성자 2개가 모두 필요할 시에는
// 반드시 모두다 만들어 주어야 한다!

// this 키워드
// 우리가 메소드를 만들다 보면
// 파라미터 혹은 메소드의 지역변수와 필드 이름이 같은 경우가 발생한다.
// 그럴 경우 해당 메소드 내부에서 우리가 필드를 지칭하기 위해
// 해당 이름을 적을 경우, 필드가 아닌 해당 파라미터 혹은 지역 변수를 지칭하게 된다.
// 그럴 경우 "필드" 를 지칭할 때 반드시 앞에
// "해당 객체의" 라는 의미로
// this. 을 붙여주게 된다.

// 상속(Inheritance)
// 프로그래밍에서 상속은 부모 클래스의 메소드를
// 자식 클래스가 또 안적더라도 그대로 사용할 수 있게 만들어주는 개념이다.
// 자바에 존재하는 모든 클래스들은 직접적인 코드는 없지만
// java.lang.Object라는 클래스의 자식 클래스들이 된다.

// 오버라이드(Override)
// 오버라이드란, 부모 클래스로부터 상속받은 메소드를 자식 클래스가 그대로 사용할 수 없는 경우,
// 자식 클래스가 자체적으로 "재정의"하는 과정을 말한다.
// 즉, java.lang.Object의 equals() 메소드를 우리가 우리 클래스 객체에서 제대로 사용하고 싶다면
// 우리 클래스 안에 재정의를 해야한다.
// 단 오버라이드를 할 때 한가지 주의할 점은
// 부모 클래스의 메소드 이름과 파라미터 타입이 정확하게 일치해야한다는 것이다!

// 객체 vs 인스턴스
// 객체: 클래스 변수
// 인스턴스: 생성자로 초기화가 된 객체


import datatype.Student;

public class Ex03Class {
    public static void main(String[] args) {
        Student s1 = null;

        s1 = new Student();

        s1.printInfo();

        Student s2 = new Student(2, "김철수");

        s1.setId(1);
        s1.setName("조재영");
        s1.setKoreanScore(90);
        s1.setEnglishScore(90);
        s1.setMathScore(91);
        s1.printInfo();

        s2.setId(2);
        s2.setName("김철수");
        s2.setKoreanScore(92);
        s2.setEnglishScore(92);
        s2.setMathScore(93);
        s2.printInfo();

        Student s2r = new Student();
        s2r.setId(2);
        s2r.setName("김철수");
        s2r.setKoreanScore(92);
        s2r.setEnglishScore(92);
        s2r.setMathScore(93);
        s2r.printInfo();

        System.out.println("s2.equals(s2r): " + s2.equals(s2r));

    }
}










